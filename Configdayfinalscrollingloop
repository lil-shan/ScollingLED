#include <Adafruit_NeoPixel.h>
#include <string.h>
#include "Font18x12.h"

#define NUM_STRIPS       18
#define LEDS_PER_STRIP   508
#define TEXT_SPACING     15

int stripPins[NUM_STRIPS] = {18, 19, 21, 22, 23, 25, 26, 27, 5, 33, 13, 4, 12, 15, 16, 2, 14, 1};
Adafruit_NeoPixel strips[NUM_STRIPS];
bool displayBuffer[NUM_STRIPS][LEDS_PER_STRIP] = {0};

const char* displayText = "welcome to tinkerspace";
int textWidth = 0;
int textOffset = LEDS_PER_STRIP;

uint8_t textColorR = 255;
uint8_t textColorG = 165;
uint8_t textColorB = 0;

unsigned long previousMillisOdd = 0;
unsigned long previousMillisEven = 0;

int offsetOdd = LEDS_PER_STRIP;
int offsetEven = LEDS_PER_STRIP;

int scrollInterval = 10;
int scrollStep = 1;
int brightness = 50;

int phaseShift = 0;

void setup() {
  for (int i = 0; i < NUM_STRIPS; i++) {
    strips[i] = Adafruit_NeoPixel(LEDS_PER_STRIP, stripPins[i], NEO_GRB + NEO_KHZ800);
    strips[i].begin();
    strips[i].setBrightness(brightness);
    strips[i].clear();
    strips[i].show();
  }
  
  textWidth = strlen(displayText) * 16;
  
  offsetEven = LEDS_PER_STRIP + phaseShift;
}

void loop() {
  unsigned long currentMillis = millis();
  
  if (currentMillis - previousMillisOdd >= scrollInterval) {
    previousMillisOdd = currentMillis;
    
    offsetOdd -= scrollStep;
    
    if (offsetOdd <= -textWidth) {
      offsetOdd = LEDS_PER_STRIP;
    }
    
    updateOddRows();
  }
  
  if (currentMillis - previousMillisEven >= scrollInterval) {
    previousMillisEven = currentMillis;
    
    offsetEven -= scrollStep;
    
    if (offsetEven <= -textWidth) {
      offsetEven = LEDS_PER_STRIP;
    }
    
    updateEvenRows();
  }
}

void updateOddRows() {
  clearOddRowsBuffer();
  
  for (int i = 0; i < strlen(displayText); i++) {
    drawCharacterOnOddRows(displayText[i], offsetOdd + i * 16);
  }
  
  int secondInstanceOffset = offsetOdd + textWidth + TEXT_SPACING;
  if (secondInstanceOffset < LEDS_PER_STRIP + textWidth) {
    for (int i = 0; i < strlen(displayText); i++) {
      drawCharacterOnOddRows(displayText[i], secondInstanceOffset + i * 16);
    }
  }
  
  for (int y = 1; y < NUM_STRIPS; y += 2) {
    for (int x = 0; x < LEDS_PER_STRIP; x++) {
      if (displayBuffer[y][x]) {
        strips[y].setPixelColor(x, strips[y].Color(textColorR, textColorG, textColorB));
      } else {
        strips[y].setPixelColor(x, 0);
      }
    }
    strips[y].show();
  }
}

void updateEvenRows() {
  clearEvenRowsBuffer();
  
  for (int i = 0; i < strlen(displayText); i++) {
    drawCharacterOnEvenRows(displayText[i], offsetEven + i * 16);
  }
  
  int secondInstanceOffset = offsetEven + textWidth + TEXT_SPACING;
  if (secondInstanceOffset < LEDS_PER_STRIP + textWidth) {
    for (int i = 0; i < strlen(displayText); i++) {
      drawCharacterOnEvenRows(displayText[i], secondInstanceOffset + i * 16);
    }
  }
  
  for (int y = 0; y < NUM_STRIPS; y += 2) {
    for (int x = 0; x < LEDS_PER_STRIP; x++) {
      if (displayBuffer[y][x]) {
        strips[y].setPixelColor(x, strips[y].Color(textColorR, textColorG, textColorB));
      } else {
        strips[y].setPixelColor(x, 0);
      }
    }
    strips[y].show();
  }
}

void drawCharacterOnOddRows(char c, int xOffset) {
  int letterIndex = getLetterIndex(c);
  if (letterIndex == -1) return;
  
  for (int row = 1; row < NUM_STRIPS; row += 2) {
    if (row < 18) {
      uint32_t rowData = font18x12[letterIndex][17 - row];
      for (int col = 0; col < 12; col++) {
        int targetX = LEDS_PER_STRIP - 1 - (xOffset + col);
        if ((targetX >= 0) && (targetX < LEDS_PER_STRIP)) {
          if (rowData & (1 << (11 - col))) {
            displayBuffer[row][targetX] = true;
          }
        }
      }
    }
  }
}

void drawCharacterOnEvenRows(char c, int xOffset) {
  int letterIndex = getLetterIndex(c);
  if (letterIndex == -1) return;
  
  for (int row = 0; row < NUM_STRIPS; row += 2) {
    if (row < 18) {
      uint32_t rowData = font18x12[letterIndex][17 - row];
      for (int col = 0; col < 12; col++) {
        int targetX = LEDS_PER_STRIP - 1 - (xOffset + col);
        if ((targetX >= 0) && (targetX < LEDS_PER_STRIP)) {
          if (rowData & (1 << (11 - col))) {
            displayBuffer[row][targetX] = true;
          }
        }
      }
    }
  }
}

void clearOddRowsBuffer() {
  for (int y = 1; y < NUM_STRIPS; y += 2) {
    memset(displayBuffer[y], 0, LEDS_PER_STRIP * sizeof(bool));
  }
}

void clearEvenRowsBuffer() {
  for (int y = 0; y < NUM_STRIPS; y += 2) {
    memset(displayBuffer[y], 0, LEDS_PER_STRIP * sizeof(bool));
  }
}

int getLetterIndex(char c) {
  if (c >= 'A' && c <= 'Z') return c - 'A';
  if (c >= 'a' && c <= 'z') return c - 'a';
  if (c == ' ') return 26;
  if (c >= '0' && c <= '9') return 27 + (c - '0');
  
  switch (c) {
    case '!': return 37; 
    case ',': return 38;
    case '.': return 39;
    case ':': return 40;
    case ';': return 41;
    case '?': return 42;
    case '"': return 43;
    case '\'': return 44;
    case '#': return 45;
    case '<': return 46;
    case '>': return 47;
    case '-': return 48;
    default: return 26;
  }
}

void setBrightness(int newBrightness) {
  brightness = constrain(newBrightness, 0, 255);
  for (int i = 0; i < NUM_STRIPS; i++) {
    strips[i].setBrightness(brightness);
  }
}

void setScrollInterval(int newInterval) {
  scrollInterval = max(newInterval, 0);
}

void setScrollStep(int newStep) {
  scrollStep = max(newStep, 1);
}

void setPhaseShift(int newPhaseShift) {
  phaseShift = newPhaseShift;
}
