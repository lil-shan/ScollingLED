#include <Adafruit_NeoPixel.h>
#include <string.h>
#include "Font18x12.h"

#define NUM_STRIPS       18
#define LEDS_PER_STRIP   508

#define FONT_WIDTH       12
#define FONT_HEIGHT      18
#define CHAR_SPACING     4
#define CHAR_PITCH       (FONT_WIDTH + CHAR_SPACING)
#define TEXT_SPACING     15

int stripPins[NUM_STRIPS] = {18, 19, 21, 22, 23, 25, 26, 27, 5, 33, 13, 4, 12, 15, 16, 2, 14, 1};
Adafruit_NeoPixel strips[NUM_STRIPS];
bool displayBuffer[NUM_STRIPS][LEDS_PER_STRIP] = {0};

const char* displayText = "welcome to tinkerspace";
int textWidth = 0;
int offsetOdd = LEDS_PER_STRIP;
int offsetEven = LEDS_PER_STRIP;

uint8_t textColorR = 255, textColorG = 165, textColorB = 0;
int scrollInterval = 10;
int scrollStep = 1;
int brightness = 50;

unsigned long previousMillisOdd = 0;
unsigned long previousMillisEven = 0;

void setup() {
  for (int i = 0; i < NUM_STRIPS; i++) {
    strips[i] = Adafruit_NeoPixel(LEDS_PER_STRIP, stripPins[i], NEO_GRB + NEO_KHZ800);
    strips[i].begin();
    strips[i].setBrightness(brightness);
    strips[i].clear();
    strips[i].show();
  }
  textWidth = strlen(displayText) * CHAR_PITCH;
}

void loop() {
  unsigned long currentMillis = millis();

  if (currentMillis - previousMillisOdd >= scrollInterval) {
    previousMillisOdd = currentMillis;
    offsetOdd -= scrollStep;
    if (offsetOdd <= -textWidth) offsetOdd = LEDS_PER_STRIP;
    updateRows(true);
  }

  if (currentMillis - previousMillisEven >= scrollInterval) {
    previousMillisEven = currentMillis;
    offsetEven -= scrollStep;
    if (offsetEven <= -textWidth) offsetEven = LEDS_PER_STRIP;
    updateRows(false);
  }
}

void updateRows(bool isOdd) {
  int startRow = isOdd ? 1 : 0;

  for (int y = startRow; y < NUM_STRIPS; y += 2)
    memset(displayBuffer[y], 0, LEDS_PER_STRIP * sizeof(bool));

  int offset = isOdd ? offsetOdd : offsetEven;

  for (int i = 0; i < strlen(displayText); i++)
    drawCharacter(displayText[i], offset + i * CHAR_PITCH, isOdd);

  int secondOffset = offset + textWidth + TEXT_SPACING;
  if (secondOffset < LEDS_PER_STRIP + textWidth) {
    for (int i = 0; i < strlen(displayText); i++)
      drawCharacter(displayText[i], secondOffset + i * CHAR_PITCH, isOdd);
  }

  for (int y = startRow; y < NUM_STRIPS; y += 2) {
    for (int x = 0; x < LEDS_PER_STRIP; x++) {
      uint32_t color = displayBuffer[y][x] ? strips[y].Color(textColorR, textColorG, textColorB) : 0;
      strips[y].setPixelColor(x, color);
    }
    strips[y].show();
  }
}

void drawCharacter(char c, int xOffset, bool isOdd) {
  int letterIndex = getLetterIndex(c);
  if (letterIndex == -1) return;

  for (int row = isOdd ? 1 : 0; row < NUM_STRIPS; row += 2) {
    if (row >= FONT_HEIGHT) continue;

    uint32_t rowData = font18x12[letterIndex][FONT_HEIGHT - 1 - row];
    for (int col = 0; col < FONT_WIDTH; col++) {
      int targetX = LEDS_PER_STRIP - 1 - (xOffset + col);
      if (targetX >= 0 && targetX < LEDS_PER_STRIP) {
        if (rowData & (1 << (FONT_WIDTH - 1 - col)))
          displayBuffer[row][targetX] = true;
      }
    }
  }
}

int getLetterIndex(char c) {
  if (c >= 'A' && c <= 'Z') return c - 'A';
  if (c >= 'a' && c <= 'z') return c - 'a';
  if (c == ' ') return 26;
  if (c >= '0' && c <= '9') return 27 + (c - '0');
  switch (c) {
    case '!': return 37;
    case ',': return 38;
    case '.': return 39;
    case ':': return 40;
    case ';': return 41;
    case '?': return 42;
    case '"': return 43;
    case '\'': return 44;
    case '#': return 45;
    case '<': return 46;
    case '>': return 47;
    case '-': return 48;
    default: return 26;
  }
}

void setBrightness(int newBrightness) {
  brightness = constrain(newBrightness, 0, 255);
  for (int i = 0; i < NUM_STRIPS; i++) {
    strips[i].setBrightness(brightness);
    strips[i].show();  // Reflect brightness immediately
  }
}

void setScrollInterval(int newInterval) {
  scrollInterval = max(newInterval, 0);
}

void setScrollStep(int newStep) {
  scrollStep = max(newStep, 1);
}
